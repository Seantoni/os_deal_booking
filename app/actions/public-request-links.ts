'use server'

import { auth, currentUser } from '@clerk/nextjs/server'
import { prisma } from '@/lib/prisma'
import { generatePublicLinkToken } from '@/lib/tokens'
import { resend, EMAIL_CONFIG } from '@/lib/email/config'
import { handleServerActionError, requireAuth } from '@/lib/utils/server-actions'
import { invalidateEntities } from '@/lib/cache'
import { extractBookingRequestFromFormData } from '@/lib/utils/form-data'
import { validateRequiredFields, isValidEmail, validateDateRange } from '@/lib/utils/validation'
import { parseDateInPanamaTime, parseEndDateInPanamaTime } from '@/lib/date/timezone'
import { buildCategoryKey } from '@/lib/category-utils'
import { getAppBaseUrl } from '@/lib/config/env'
import { logger } from '@/lib/logger'
import { generateRequestName, countBusinessRequests } from '@/lib/utils/request-naming'

/**
 * Generate a public request link and send it via email
 * Supports sending to multiple email addresses
 */
export async function generateAndSendPublicLink(recipientEmails: string | string[]) {
  const authResult = await requireAuth()
  if (!('userId' in authResult)) {
    return authResult
  }

  const { userId } = authResult

  try {
    // Normalize to array and filter valid emails
    const emailArray = Array.isArray(recipientEmails) ? recipientEmails : [recipientEmails]
    const validEmails = emailArray
      .map(e => e?.toLowerCase().trim())
      .filter(e => e && e.includes('@'))
    
    // Remove duplicates
    const uniqueEmails = [...new Set(validEmails)]

    if (uniqueEmails.length === 0) {
      return { success: false, error: 'No se proporcionaron direcciones de correo electrónico válidas' }
    }

    // Get user information for email
    const user = await currentUser()
    const userEmail = user?.emailAddresses[0]?.emailAddress
    const userName = user?.firstName || user?.lastName ? `${user.firstName || ''} ${user.lastName || ''}`.trim() : userEmail || 'Team Member'

    // Generate unique token
    const token = generatePublicLinkToken()

    // Create public link record (store first email as primary, all emails in a note)
    const primaryEmail = uniqueEmails[0]
    const publicLink = await prisma.publicRequestLink.create({
      data: {
        token,
        createdBy: userId,
        recipientEmail: primaryEmail,
      },
    })

    // Build public URL
    const baseUrl = getAppBaseUrl()
    const publicUrl = `${baseUrl}/booking-request/${token}`

    // Send email with link to all recipients
    try {
      await resend.emails.send({
        from: `OS Deals Booking <${EMAIL_CONFIG.from}>`,
        to: uniqueEmails, // All recipient emails
        cc: userEmail ? [userEmail] : [], // Copy to: logged-in user who created the link
        replyTo: userEmail || EMAIL_CONFIG.replyTo,
        subject: 'Complete su Solicitud de Booking - OS Deals',
        html: renderPublicLinkEmail({
          recipientEmail: uniqueEmails.join(', '),
          publicUrl,
          senderName: userName,
        }),
      })

      logger.info(`Public link sent to ${uniqueEmails.join(', ')} (CC: ${userEmail || 'none'}) - generated by ${userId}`)
    } catch (emailError) {
      logger.error('Error sending public link email:', emailError)
      // Delete the link if email failed
      await prisma.publicRequestLink.delete({ where: { id: publicLink.id } })
      return {
        success: false,
        error: 'Error al enviar el correo electrónico. Por favor intente nuevamente.',
      }
    }

    return {
      success: true,
      data: {
        token: publicLink.token,
        url: publicUrl,
        recipientEmail: primaryEmail,
        recipientEmails: uniqueEmails,
        createdAt: publicLink.createdAt,
      },
    }
  } catch (error) {
    return handleServerActionError(error, 'generateAndSendPublicLink')
  }
}

/**
 * Validate a public request link token
 */
export async function validatePublicLinkToken(token: string) {
  try {
    const publicLink = await prisma.publicRequestLink.findUnique({
      where: { token },
    })

    if (!publicLink) {
      return { valid: false, error: 'Enlace inválido' }
    }

    if (publicLink.isUsed) {
      return { valid: false, error: 'Este enlace ya ha sido utilizado' }
    }

    return { valid: true, publicLink }
  } catch (error) {
    logger.error('Error validating public link token:', error)
    return { valid: false, error: 'Error al validar el enlace' }
  }
}

/**
 * Get public link by token
 */
export async function getPublicLinkByToken(token: string) {
  try {
    const publicLink = await prisma.publicRequestLink.findUnique({
      where: { token },
      include: {
        bookingRequest: true,
      },
    })

    return publicLink
  } catch (error) {
    logger.error('Error fetching public link:', error)
    return null
  }
}

/**
 * Submit a booking request from public form (no authentication required)
 * Sets status to 'approved' and links to the public link token
 */
export async function submitPublicBookingRequest(token: string, formData: FormData) {
  try {
    // Validate token first
    const validation = await validatePublicLinkToken(token)
    if (!validation.valid || !validation.publicLink) {
      return {
        success: false,
        error: validation.error || 'Enlace inválido o expirado',
      }
    }

    const publicLink = validation.publicLink

    // Extract all fields using utility
    const fields = extractBookingRequestFromFormData(formData)

    // Validate required fields
    const missing = validateRequiredFields(fields, ['name', 'businessEmail', 'startDate', 'endDate'])
    if (missing.length > 0) {
      return {
        success: false,
        error: `Campos requeridos faltantes: ${missing.join(', ')}`,
      }
    }

    // Validate email format
    if (!isValidEmail(fields.businessEmail!)) {
      return { success: false, error: 'Formato de correo electrónico inválido' }
    }

    // Parse dates in Panama timezone for consistency
    const startDateTime = parseDateInPanamaTime(fields.startDate!)
    const endDateTime = parseEndDateInPanamaTime(fields.endDate!)

    // Validate date range
    const dateValidation = validateDateRange(startDateTime, endDateTime)
    if (!dateValidation.valid) {
      return { success: false, error: dateValidation.error! }
    }

    // Build standardized category key
    const standardizedCategory = buildCategoryKey(
      fields.parentCategory || null,
      fields.subCategory1 || null,
      fields.subCategory2 || null,
      fields.subCategory3 || null,
      fields.category
    )

    // Generate request name with format: "Business Name | Dec-15-2025 | #3"
    const existingCount = await countBusinessRequests(fields.name!)
    const requestName = generateRequestName(fields.name!, existingCount)

    // Create booking request with status 'approved' (as requested)
    // Use the userId from the public link creator (createdBy)
    const bookingRequest = await prisma.bookingRequest.create({
      data: {
        name: requestName,
        category: standardizedCategory,
        parentCategory: fields.parentCategory,
        subCategory1: fields.subCategory1,
        subCategory2: fields.subCategory2,
        merchant: fields.merchant,
        businessEmail: fields.businessEmail!,
        startDate: startDateTime,
        endDate: endDateTime,
        status: 'approved', // Public submissions are automatically approved
        sourceType: 'public_link',
        publicLinkToken: token,
        userId: publicLink.createdBy, // Use the creator's userId
        processedAt: new Date(),
        // Configuración: Configuración General y Vigencia
        campaignDuration: fields.campaignDuration,
        // Operatividad: Operatividad y Pagos
        redemptionMode: fields.redemptionMode,
        isRecurring: fields.isRecurring,
        recurringOfferLink: fields.recurringOfferLink,
        paymentType: fields.paymentType,
        paymentInstructions: fields.paymentInstructions,
        // Directorio: Directorio de Responsables
        redemptionContactName: fields.redemptionContactName,
        redemptionContactEmail: fields.redemptionContactEmail,
        redemptionContactPhone: fields.redemptionContactPhone,
        // Fiscales: Datos Fiscales, Bancarios y de Ubicación
        legalName: fields.legalName,
        rucDv: fields.rucDv,
        bankAccountName: fields.bankAccountName,
        bank: fields.bank,
        accountNumber: fields.accountNumber,
        accountType: fields.accountType,
        addressAndHours: fields.addressAndHours,
        province: fields.province,
        district: fields.district,
        corregimiento: fields.corregimiento,
        // Negocio: Reglas de Negocio y Restricciones
        includesTaxes: fields.includesTaxes,
        validOnHolidays: fields.validOnHolidays,
        hasExclusivity: fields.hasExclusivity,
        blackoutDates: fields.blackoutDates,
        exclusivityCondition: fields.exclusivityCondition,
        giftVouchers: fields.giftVouchers,
        hasOtherBranches: fields.hasOtherBranches,
        vouchersPerPerson: fields.vouchersPerPerson,
        commission: fields.commission,
        // Descripción: Descripción y Canales de Venta
        redemptionMethods: fields.redemptionMethods,
        contactDetails: fields.contactDetails,
        socialMedia: fields.socialMedia,
        // Contenido: AI-Generated Content Fields
        whatWeLike: fields.whatWeLike,
        aboutCompany: fields.aboutCompany,
        aboutOffer: fields.aboutOffer,
        goodToKnow: fields.goodToKnow,
        // Estructura: Estructura de la Oferta
        pricingOptions: fields.pricingOptions,
        dealImages: fields.dealImages,
        // Políticas: Políticas Generales
        cancellationPolicy: fields.cancellationPolicy,
        marketValidation: fields.marketValidation,
        additionalComments: fields.additionalComments,
      },
    })

    // Create an approved event in the calendar (matching the approved booking request status)
    // This allows the event to be booked/rejected directly like internal requests
    const event = await prisma.event.create({
      data: {
        name: bookingRequest.name,
        description: null, // Events can have their own description if needed
        category: standardizedCategory,
        parentCategory: bookingRequest.parentCategory,
        subCategory1: bookingRequest.subCategory1,
        subCategory2: bookingRequest.subCategory2,
        merchant: bookingRequest.merchant,
        startDate: startDateTime,
        endDate: endDateTime,
        status: 'approved', // Create as approved to match booking request status and enable book/reject actions
        userId: publicLink.createdBy, // Use the creator's userId
        bookingRequestId: bookingRequest.id,
      },
    })

    // Link the event to the booking request
    await prisma.bookingRequest.update({
      where: { id: bookingRequest.id },
      data: { eventId: event.id },
    })

    // Mark the public link as used
    await prisma.publicRequestLink.update({
      where: { id: publicLink.id },
      data: {
        isUsed: true,
        usedAt: new Date(),
      },
    })

    // Revalidate cache
    invalidateEntities(['booking-requests', 'public-request-links', 'events'])

    return {
      success: true,
      data: {
        bookingRequestId: bookingRequest.id,
        requestName: bookingRequest.name,
      },
    }
  } catch (error) {
    logger.error('Error submitting public booking request:', error)
    return {
      success: false,
      error: error instanceof Error ? error.message : 'Error al enviar la solicitud de booking',
    }
  }
}

/**
 * Render email HTML for public link
 */
function renderPublicLinkEmail({
  recipientEmail,
  publicUrl,
  senderName,
}: {
  recipientEmail: string
  publicUrl: string
  senderName: string
}): string {
  return `
<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Complete su Solicitud de Booking</title>
</head>
<body style="font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, 'Helvetica Neue', Arial, sans-serif; line-height: 1.6; color: #333; max-width: 600px; margin: 0 auto; padding: 20px; background-color: #f5f5f5;">
  <div style="background-color: white; border-radius: 8px; padding: 30px; box-shadow: 0 2px 4px rgba(0,0,0,0.1);">
    <h1 style="color: #2563eb; margin-top: 0; font-size: 24px;">Complete su Solicitud de Booking</h1>
    
    <p>Hola,</p>
    
    <p>${senderName} le ha invitado a completar un formulario de solicitud de booking para OS Deals.</p>
    
    <p>Haga clic en el botón a continuación para acceder al formulario y enviar su solicitud de booking:</p>
    
    <div style="text-align: center; margin: 30px 0;">
      <a href="${publicUrl}" style="display: inline-block; background-color: #2563eb; color: white; text-decoration: none; padding: 12px 24px; border-radius: 6px; font-weight: 600; font-size: 16px;">Acceder al Formulario de Solicitud</a>
    </div>
    
    <p style="color: #666; font-size: 14px;">O copie y pegue este enlace en su navegador:</p>
    <p style="color: #2563eb; font-size: 14px; word-break: break-all; background-color: #f0f0f0; padding: 10px; border-radius: 4px;">${publicUrl}</p>
    
    <p style="color: #666; font-size: 14px; margin-top: 30px;">Este enlace le permitirá enviar una solicitud de booking sin necesidad de iniciar sesión.</p>
    
    <p style="color: #666; font-size: 14px;">Si no esperaba este correo electrónico, por favor ignórelo o contacte a nuestro equipo.</p>
    
    <hr style="border: none; border-top: 1px solid #e5e5e5; margin: 30px 0;">
    
    <p style="color: #999; font-size: 12px; margin-bottom: 0;">Este es un mensaje automatizado del Sistema de Booking de OS Deals.</p>
  </div>
</body>
</html>
  `
}

